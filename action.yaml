name: 'Compute Version'
description: 'Compute version based on branch name and git tags'
inputs:
  test_version_tag:
    description: 'Optional test version tag for testing purposes'
    required: false
    default: ''
  test_branch_name:
    description: 'Optional test branch name for testing purposes'
    required: false
    default: ''
outputs:
  version:
    description: 'The computed version string'
runs:
  using: 'composite'
  steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Compute and Validate Version
      shell: bash
      run: |
        # Initialize variables
        branchName="${{ inputs.test_branch_name }}"
        if [[ -z "$branchName" ]]; then
          branchName=$(git rev-parse --abbrev-ref HEAD)
        fi
        latestReleaseVersion=$(git tag --sort=-v:refname | grep '^v' | head -n 1 | sed 's/^v//')
        if [[ -z "$latestReleaseVersion" ]]; then
          latestVersion="0.1.0" # SemVer initial version.
        else
          latestVersion="$latestReleaseVersion"
        fi

        # Extracting the short SHA from the latest commit
        shortSHA=$(git rev-parse --short HEAD)

        # Initialize base version for new work
        IFS='.' read -ra VER <<< "$latestVersion"
        ((VER[2]++))
        baseVersion="${VER[0]}.${VER[1]}.${VER[2]}"

        # Construct version template based on branch type
        versionTemplate="${baseVersion}-"
        case "$branchName" in
          feature/*|bugfix/*|alpha/*|beta/*)
            jiraCardID=$(echo $branchName | grep -oP '(?<=/)[A-Z]+-\d+' || echo "")
            if [[ -n "$jiraCardID" ]]; then
              versionTemplate+="${branchName%%/*}.${jiraCardID}.${shortSHA}"
            else
              versionTemplate+="${branchName%%/*}.${shortSHA}"
            fi
            ;;
          develop*)
            versionTemplate="${baseVersion}-develop"
            ;;
          release*)
            # Directly use baseVersion for release branches; build number will be appended later if needed
            versionTemplate="${baseVersion}"
            ;;
          *)
            versionTemplate+="${branchName%%/*}.${shortSHA}" # Default case for any other branch types
            ;;
        esac

        # Determine the next build number and adjust newVersion accordingly
        regexToMatch="${versionTemplate//./\\.}+([0-9]+)$" # Escaping dots for regex matching and preparing to capture build number
        currentBuildNumber=$(git tag --list | grep -P "$regexToMatch" | sed 's/^.*+\([0-9]\+\)$/\1/' | sort -nr | head -n 1)

        if [[ "$branchName" == "release/"* ]]; then
          if [[ -n "$currentBuildNumber" ]]; then # If a build number is found, increment it
            buildNumber=$((currentBuildNumber + 1))
            newVersion="${baseVersion}+${buildNumber}"  # Append build number for subsequent release builds
          else
            newVersion="${baseVersion}"  # No build number for the initial release build
          fi
        else
          if [[ -n "$currentBuildNumber" ]]; then
            buildNumber=$((currentBuildNumber + 1))
          else
            buildNumber=1
          fi
          newVersion="${versionTemplate}+${buildNumber}"  # Append build number for non-release branches
        fi

        # Output the computed version
        echo "Computed Version: $newVersion"
        echo "version=${newVersion}" >> $GITHUB_OUTPUT
