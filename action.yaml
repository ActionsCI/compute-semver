name: 'Compute Version'
description: 'Compute version based on branch name and git tags'
inputs:
  test_version_tag:
    description: 'Optional test version tag for testing purposes'
    required: false
    default: ''
  test_branch_name:
    description: 'Optional test branch name for testing purposes'
    required: false
    default: ''
outputs:
  version:
    description: 'The computed version string'
runs:
  using: 'composite'
  steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Compute and Validate Version
      shell: bash
      run: |
        # Initialize variables
        initialVersion=false
        echo "Initial version set to false"
        branchName="${{ inputs.test_branch_name }}"
        if [[ -z "$branchName" ]]; then
          branchName=$(git rev-parse --abbrev-ref HEAD)
        fi
        echo "Branch name: $branchName"

        latestReleaseVersion=$(git tag --sort=-v:refname | grep '^v' | head -n 1 ) 
        echo "Latest release version: $latestReleaseVersion"
        if [[ -z "$latestReleaseVersion" ]]; then
          latestVersion="0.1.0" # SemVer initial version.
          initialVersion=true
        else
          latestVersion="$latestReleaseVersion"
        fi
        echo "Latest version: $latestVersion, initial version: $initialVersion"

        # Extracting the short SHA from the latest commit
        shortSHA=$(git rev-parse --short HEAD)
        echo "Short SHA: $shortSHA"

        if [[ $initialVersion == false ]]; then
          # Initialize base version for new work
          IFS='.' read -ra VER <<< "$latestVersion"
          ((VER[2]++))
          baseVersion="${VER[0]}.${VER[1]}.${VER[2]}"
        else
          baseVersion="${latestVersion}"
        fi
        echo "Base version for new work: $baseVersion"

        # Construct version template based on branch type
        versionPostfixTemplate=""
        echo "Starting construction of version postfix template..."

        case "$branchName" in
          feature/*|bugfix/*|alpha/*|beta/*)
            jiraCardID=$(echo $branchName | grep -oP '(?<=/)[A-Z]+-\d+' || echo "")
            if [[ -n "$jiraCardID" ]]; then
              versionPostfixTemplate="-${branchName%%/*}.${jiraCardID}.${shortSHA}"
            else
              versionPostfixTemplate="-${branchName%%/*}.${shortSHA}"
            fi
            ;;
          develop*)
            versionPostfixTemplate="-develop.${shortSHA}"
            ;;
          release*)
            versionPostfixTemplate=""  # Empty for initial release work; build number appended later if needed
            ;;
          *)
            versionPostfixTemplate="-${branchName%%/*}.${shortSHA}"  # Default case for any other branch types
            ;;
        esac
        echo "Version postfix template: $versionPostfixTemplate"

        # Correct regexToMatch construction error
        regexToMatch="${baseVersion}${versionPostfixTemplate//./\\.}\+([0-9]+)$"
        echo "Regex to match: $regexToMatch"

        # Determine the next build number
        echo "Determining next build number..."
        currentBuildNumber=$(git tag --list | grep -P "$regexToMatch" | sed 's/^.*+\([0-9]+\)$/\1/' | sort -nr | head -n 1)
        echo "Current build number: $currentBuildNumber"

        if [[ -n "$currentBuildNumber" ]]; then
          buildNumber=$((currentBuildNumber + 1))
        else
          buildNumber=1
        fi
        echo "Next build number: $buildNumber"

        # Correctly construct newVersion
        if [[ "$branchName" == "release/"* && -z "$currentBuildNumber" ]]; then
          newVersion="${baseVersion}"  # No build number for the initial release build
        else
          newVersion="${baseVersion}${versionPostfixTemplate}+${buildNumber}"  # Append build number correctly for all cases
        fi
        echo "Computed Version: $newVersion"
        echo "version=${newVersion}" >> $GITHUB_OUTPUT
